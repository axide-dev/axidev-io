name: Integration tests (manual)

# Manual workflow to run the integration tests. Integration tests are built
# and executed from a dedicated test executable (`typr-io-integration-tests`)
# and are no longer bundled into the lightweight unit test binary. The
# integration executable is produced when CMake is configured with:
#
#   -DTYPR_IO_BUILD_TESTS=ON -DTYPR_IO_BUILD_INTEGRATION_TESTS=ON
#
# Integration tests are often interactive and may require GUI/device
# permissions. The workflow exposes a few environment variables useful for
# CI or local runs:
#
# - TYPR_IO_RUN_INTEGRATION_TESTS=1  : historically used to enable integration tests
# - TYPR_IO_AUTO_CONFIRM=1           : auto-confirm prompts (non-interactive)
# - TYPR_IO_INTERACTIVE=(true|yes|1) : enable interactive prompts
#
# By default this workflow sets `TYPR_IO_RUN_INTEGRATION_TESTS=1`,
# `TYPR_IO_AUTO_CONFIRM=1` and `TYPR_IO_INTERACTIVE=1` so the integration
# binaries are built in an interactive-friendly mode. The workflow is intended
# to only build the binaries so they can be run/tested outside of CI.
on:
  workflow_dispatch:
    # no inputs; workflow is always interactive

permissions:
  contents: write

# Note: the previous workflow used a single matrix job with step-level `if`
# checks to vary behavior per platform. Split that into individual jobs below
# (one job per OS/arch) so platform-specific logic lives in the job and is
# easier to reason about. Each job uploads an artifact that includes both
# the OS and the architecture so the release job can pick them up later.

jobs:
  integration-ubuntu-x64:
    name: Integration tests on ubuntu-latest (x86_64)
    runs-on: ubuntu-latest
    env:
      TYPR_IO_RUN_INTEGRATION_TESTS: "1"
      TYPR_IO_AUTO_CONFIRM: "1"
      TYPR_IO_INTERACTIVE: "1"
      DISPLAY: ":99"
      OS_NAME: ubuntu-latest
      ARCH: x64

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies (Linux)
        run: |
          sudo apt-get update
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
            build-essential cmake libx11-dev libxi-dev libxtst-dev \
            libxrandr-dev libxcursor-dev libxinerama-dev xvfb
          # Try to enable uinput device (sender backend may require it).
          sudo modprobe uinput || true
          sudo chmod 666 /dev/uinput || true

      - name: Start Xvfb (Linux)
        run: |
          # Start Xvfb in the background so GUI-related injection can run.
          Xvfb :99 -screen 0 1024x768x24 & sleep 2

      - name: Clean stale build directory (Unix)
        run: rm -rf build

      - name: Configure (CMake, Linux)
        run: cmake -S . -B build -DTYPR_IO_BUILD_TESTS=ON -DTYPR_IO_BUILD_INTEGRATION_TESTS=ON -DCMAKE_BUILD_TYPE=Release

      - name: Build (CMake)
        run: cmake --build build --config Release --parallel

      - name: Find integration test binary (Unix)
        id: find-integration-binary
        run: |
          # Find the built integration test executable and emit its path as step output.
          found=$(find build -type f -name 'typr-io-integration-tests*' -print -quit || true)
          if [ -n "$found" ]; then
            echo "path=$found" >> $GITHUB_OUTPUT
          else
            echo "path=" >> $GITHUB_OUTPUT
          fi

      - name: Upload integration test binary
        if: steps.find-integration-binary.outputs.path != ''
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-binary-${{ env.OS_NAME }}-${{ env.ARCH }}
          path: ${{ steps.find-integration-binary.outputs.path }}

  integration-ubuntu-arm64:
    name: Integration tests on ubuntu-24.04-arm (arm64)
    runs-on: ubuntu-24.04-arm
    env:
      TYPR_IO_RUN_INTEGRATION_TESTS: "1"
      TYPR_IO_AUTO_CONFIRM: "1"
      TYPR_IO_INTERACTIVE: "1"
      DISPLAY: ":99"
      OS_NAME: ubuntu-22.04-arm64
      ARCH: arm64

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies (Linux)
        run: |
          sudo apt-get update
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
            build-essential cmake libx11-dev libxi-dev libxtst-dev \
            libxrandr-dev libxcursor-dev libxinerama-dev xvfb
          # Try to enable uinput device (sender backend may require it).
          sudo modprobe uinput || true
          sudo chmod 666 /dev/uinput || true

      - name: Start Xvfb (Linux)
        run: |
          # Start Xvfb in the background so GUI-related injection can run.
          Xvfb :99 -screen 0 1024x768x24 & sleep 2

      - name: Clean stale build directory (Unix)
        run: rm -rf build

      - name: Configure (CMake, Linux / arm64)
        # On an arm64 runner this config will build a native arm64 binary.
        run: cmake -S . -B build -DTYPR_IO_BUILD_TESTS=ON -DTYPR_IO_BUILD_INTEGRATION_TESTS=ON -DCMAKE_BUILD_TYPE=Release

      - name: Build (CMake)
        run: cmake --build build --config Release --parallel

      - name: Find integration test binary (Unix)
        id: find-integration-binary
        run: |
          found=$(find build -type f -name 'typr-io-integration-tests*' -print -quit || true)
          if [ -n "$found" ]; then
            echo "path=$found" >> $GITHUB_OUTPUT
          else
            echo "path=" >> $GITHUB_OUTPUT
          fi

      - name: Upload integration test binary
        if: steps.find-integration-binary.outputs.path != ''
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-binary-${{ env.OS_NAME }}-${{ env.ARCH }}
          path: ${{ steps.find-integration-binary.outputs.path }}

  integration-macos-x64:
    name: Integration tests on macos-latest (x86_64)
    runs-on: macos-latest
    env:
      TYPR_IO_RUN_INTEGRATION_TESTS: "1"
      TYPR_IO_AUTO_CONFIRM: "1"
      TYPR_IO_INTERACTIVE: "1"
      DISPLAY: ":99"
      OS_NAME: macos-latest
      ARCH: x64

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies (macOS)
        run: |
          brew update
          brew install cmake

      - name: Clean stale build directory (Unix)
        run: rm -rf build

      - name: Configure (CMake, macOS / x86_64)
        run: cmake -S . -B build -DTYPR_IO_BUILD_TESTS=ON -DTYPR_IO_BUILD_INTEGRATION_TESTS=ON -DCMAKE_BUILD_TYPE=Release -DCMAKE_OSX_ARCHITECTURES=x86_64

      - name: Build (CMake)
        run: cmake --build build --config Release --parallel

      - name: Find integration test binary (Unix)
        id: find-integration-binary
        run: |
          found=$(find build -type f -name 'typr-io-integration-tests*' -print -quit || true)
          if [ -n "$found" ]; then
            echo "path=$found" >> $GITHUB_OUTPUT
          else
            echo "path=" >> $GITHUB_OUTPUT
          fi

      - name: Upload integration test binary
        if: steps.find-integration-binary.outputs.path != ''
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-binary-${{ env.OS_NAME }}-${{ env.ARCH }}
          path: ${{ steps.find-integration-binary.outputs.path }}

  integration-macos-arm64:
    name: Integration tests on macos-latest (arm64)
    runs-on: macos-latest
    env:
      TYPR_IO_RUN_INTEGRATION_TESTS: "1"
      TYPR_IO_AUTO_CONFIRM: "1"
      TYPR_IO_INTERACTIVE: "1"
      DISPLAY: ":99"
      OS_NAME: macos-latest
      ARCH: arm64

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies (macOS)
        run: |
          brew update
          brew install cmake

      - name: Clean stale build directory (Unix)
        run: rm -rf build

      - name: Configure (CMake, macOS / arm64)
        # Prefer building for arm64 explicitly. On Apple runners this should
        # produce an arm64 binary; on other macOS hosts CMake/Xcode may
        # cross-compile if supported.
        run: cmake -S . -B build -DTYPR_IO_BUILD_TESTS=ON -DTYPR_IO_BUILD_INTEGRATION_TESTS=ON -DCMAKE_BUILD_TYPE=Release -DCMAKE_OSX_ARCHITECTURES=arm64

      - name: Build (CMake)
        run: cmake --build build --config Release --parallel

      - name: Find integration test binary (Unix)
        id: find-integration-binary
        run: |
          found=$(find build -type f -name 'typr-io-integration-tests*' -print -quit || true)
          if [ -n "$found" ]; then
            echo "path=$found" >> $GITHUB_OUTPUT
          else
            echo "path=" >> $GITHUB_OUTPUT
          fi

      - name: Upload integration test binary
        if: steps.find-integration-binary.outputs.path != ''
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-binary-${{ env.OS_NAME }}-${{ env.ARCH }}
          path: ${{ steps.find-integration-binary.outputs.path }}

  integration-windows-x64:
    name: Integration tests on windows-latest (x86_64)
    runs-on: windows-latest
    env:
      TYPR_IO_RUN_INTEGRATION_TESTS: "1"
      TYPR_IO_AUTO_CONFIRM: "1"
      TYPR_IO_INTERACTIVE: "1"
      OS_NAME: windows-latest
      ARCH: x64

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies (Windows)
        run: |
          choco install -y cmake

      - name: Clean stale build directory (Windows)
        shell: pwsh
        run: |
          $path = 'build'
          if (Test-Path -LiteralPath $path) {
            try {
              Remove-Item -LiteralPath $path -Recurse -Force -ErrorAction Stop -Verbose
            } catch {
              Write-Host "Warning: failed to remove '$path': $($_.Exception.Message)"
              # Intentionally don't rethrow so the workflow step succeeds even if removal fails
            }
          } else {
            Write-Host "No build directory to remove"
          }

      - name: Configure (CMake, Windows)
        run: cmake -S . -B build -G "Visual Studio 17 2022" -A x64 -DTYPR_IO_BUILD_TESTS=ON -DTYPR_IO_BUILD_INTEGRATION_TESTS=ON

      - name: Build (CMake)
        run: cmake --build build --config Release --parallel

      - name: Find integration test binary (Windows)
        id: find-integration-binary
        shell: pwsh
        run: |
          $found = Get-ChildItem -Path build -Recurse -File -ErrorAction SilentlyContinue | Where-Object { $_.Name -like 'typr-io-integration-tests*.exe' } | Select-Object -First 1
          if ($found) {
            Write-Output "path=$($found.FullName)" >> $env:GITHUB_OUTPUT
          } else {
            Write-Output "path=" >> $env:GITHUB_OUTPUT
          }

      - name: Upload integration test binary
        if: steps.find-integration-binary.outputs.path != ''
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-binary-${{ env.OS_NAME }}-${{ env.ARCH }}
          path: ${{ steps.find-integration-binary.outputs.path }}

  integration-windows-arm64:
    name: Integration tests on windows-latest (arm64)
    runs-on: windows-latest
    env:
      TYPR_IO_RUN_INTEGRATION_TESTS: "1"
      TYPR_IO_AUTO_CONFIRM: "1"
      TYPR_IO_INTERACTIVE: "1"
      OS_NAME: windows-latest
      ARCH: arm64

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies (Windows)
        run: |
          choco install -y cmake

      - name: Clean stale build directory (Windows)
        shell: pwsh
        run: |
          $path = 'build'
          if (Test-Path -LiteralPath $path) {
            try {
              Remove-Item -LiteralPath $path -Recurse -Force -ErrorAction Stop -Verbose
            } catch {
              Write-Host "Warning: failed to remove '$path': $($_.Exception.Message)"
              # Intentionally don't rethrow so the workflow step succeeds even if removal fails
            }
          } else {
            Write-Host "No build directory to remove"
          }

      - name: Configure (CMake, Windows ARM64)
        run: cmake -S . -B build -G "Visual Studio 17 2022" -A ARM64 -DTYPR_IO_BUILD_TESTS=ON -DTYPR_IO_BUILD_INTEGRATION_TESTS=ON

      - name: Build (CMake)
        run: cmake --build build --config Release --parallel

      - name: Find integration test binary (Windows)
        id: find-integration-binary
        shell: pwsh
        run: |
          $found = Get-ChildItem -Path build -Recurse -File -ErrorAction SilentlyContinue | Where-Object { $_.Name -like 'typr-io-integration-tests*.exe' } | Select-Object -First 1
          if ($found) {
            Write-Output "path=$($found.FullName)" >> $env:GITHUB_OUTPUT
          } else {
            Write-Output "path=" >> $env:GITHUB_OUTPUT
          }

      - name: Upload integration test binary
        if: steps.find-integration-binary.outputs.path != ''
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-binary-${{ env.OS_NAME }}-${{ env.ARCH }}
          path: ${{ steps.find-integration-binary.outputs.path }}

  release:
    name: Create integration test release
    runs-on: ubuntu-latest
    needs:
      - integration-ubuntu-x64
      - integration-ubuntu-arm64
      - integration-macos-x64
      - integration-macos-arm64
      - integration-windows-x64
      - integration-windows-arm64
    if: ${{ always() }}
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all workflow artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
        continue-on-error: true

      - name: Prepare release assets
        run: |
          set -e
          mkdir -p release-assets
          shopt -s globstar || true
          for d in artifacts/*; do
            if [ -d "$d" ]; then
              for f in "$d"/**/typr-io-integration-tests*; do
                if [ -f "$f" ]; then
                  os=$(basename "$d" | sed 's/^integration-test-binary-//')
                  name="typr-io-integration-tests-${os}"
                  ext="${f##*.}"
                  if [ "$ext" = "$f" ]; then
                    # No extension
                    cp "$f" "release-assets/${name}"
                  else
                    cp "$f" "release-assets/${name}.${ext}"
                  fi
                fi
              done
            fi
          done
          echo "Prepared release assets:"
          ls -la release-assets || true

      - name: Check for release assets
        id: check-assets
        run: |
          if [ -n "$(ls -A release-assets 2>/dev/null || true)" ]; then
            echo "has_assets=true" >> $GITHUB_OUTPUT
          else
            echo "has_assets=false" >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub release and upload assets
        if: steps.check-assets.outputs.has_assets == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          UTC1_DATE=$(python3 -c "from datetime import datetime, timedelta; t=datetime.utcnow()+timedelta(hours=1); print(t.strftime('%Y-%m-%d'))")
          UTC1_HM_LABEL=$(python3 -c "from datetime import datetime, timedelta; t=datetime.utcnow()+timedelta(hours=1); print(t.strftime('%H:%M'))")
          UTC1_HM_TAG=$(python3 -c "from datetime import datetime, timedelta; t=datetime.utcnow()+timedelta(hours=1); print(t.strftime('%H%M'))")
          RELEASE_NAME="${UTC1_DATE} ${UTC1_HM_LABEL} integration tests"
          TAG="integration-tests-${UTC1_DATE}-${UTC1_HM_TAG}"
          BODY="Integration test binaries produced by workflow run ${GITHUB_RUN_ID}."
          echo "Creating release ${RELEASE_NAME} (tag ${TAG})"
          resp=$(curl -s -X POST -H "Authorization: token $GITHUB_TOKEN" -H "Content-Type: application/json" \
            -d "{\"tag_name\":\"$TAG\",\"name\":\"$RELEASE_NAME\",\"body\":\"$BODY\",\"draft\":false,\"prerelease\":false}" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases")
          release_id=$(echo "$resp" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('id') or '')")
          upload_url=$(echo "$resp" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('upload_url') or '')")
          if [ -z "$release_id" ]; then
            echo "Release creation failed or already exists; fetching existing release by tag..."
            resp=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/$TAG")
            release_id=$(echo "$resp" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('id') or '')")
            upload_url=$(echo "$resp" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('upload_url') or '')")
          fi
          if [ -z "$upload_url" ]; then
            echo "Failed to determine upload URL for release"
            echo "$resp"
            exit 1
          fi
          # Trim the template suffix from upload_url if present (e.g. "{?name,label}")
          upload_url="${upload_url%\{*}"
          # Upload assets (delete any existing duplicate assets first)
          assets=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/$release_id/assets")
          for file in release-assets/*; do
            if [ -f "$file" ]; then
              name=$(basename "$file")
              # Delete existing asset with same name, if present
              asset_id=$(echo "$assets" | python3 -c "import sys, json; a=json.load(sys.stdin); import sys; name=sys.argv[1]; print(next((x.get('id') for x in a if x.get('name')==name), ''))" "$name")
              if [ -n "$asset_id" ] && [ "$asset_id" != "None" ]; then
                echo "Deleting existing asset $name (id $asset_id)"
                curl -s -X DELETE -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/assets/$asset_id"
              fi
              echo "Uploading $name"
              curl --fail -s -X POST -H "Authorization: token $GITHUB_TOKEN" -H "Content-Type: application/octet-stream" --data-binary @"$file" "${upload_url}?name=${name}"
            fi
          done
          echo "Release ${RELEASE_NAME} ready."
