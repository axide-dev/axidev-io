name: Integration tests (manual)

# Manual workflow to run the integration tests. Integration tests are built
# and executed from a dedicated test executable (`typr-io-integration-tests`)
# and are no longer bundled into the lightweight unit test binary. The
# integration executable is produced when CMake is configured with:
#
#   -DTYPR_IO_BUILD_TESTS=ON -DTYPR_IO_BUILD_INTEGRATION_TESTS=ON
#
# Integration tests are often interactive and may require GUI/device
# permissions. The workflow exposes a few environment variables useful for
# CI or local runs:
#
# - TYPR_IO_RUN_INTEGRATION_TESTS=1  : historically used to enable integration tests
# - TYPR_IO_AUTO_CONFIRM=1           : auto-confirm prompts (non-interactive)
# - TYPR_IO_INTERACTIVE=(true|yes|1) : enable interactive prompts
#
# By default this workflow sets `TYPR_IO_RUN_INTEGRATION_TESTS=1` and
# `TYPR_IO_AUTO_CONFIRM=1` so tests can run non-interactively in CI. To run
# interactively, trigger the workflow manually and set the `interactive`
# input to `true`.
on:
  workflow_dispatch:
    inputs:
      interactive:
        description: "Run tests in interactive mode (set to true to enable interactive prompts)"
        required: false
        default: "false"

permissions:
  contents: write

jobs:
  integration:
    name: Integration tests on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    env:
      # Always enable integration tests for this workflow
      TYPR_IO_RUN_INTEGRATION_TESTS: "1"
      # Default to auto-confirm (so the workflow is non-interactive by default)
      TYPR_IO_AUTO_CONFIRM: "1"
      # Pass through the interactive input (string 'true'/'false'); the test
      # helper recognizes '1', 'true', 'yes' as enabled.
      TYPR_IO_INTERACTIVE: ${{ github.event.inputs.interactive }}
      # For Linux (Xvfb) we'll use :99; harmless to set on macOS too.
      DISPLAY: ":99"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
            build-essential cmake libx11-dev libxi-dev libxtst-dev \
            libxrandr-dev libxcursor-dev libxinerama-dev xvfb
          # Try to enable uinput device (sender backend may require it).
          sudo modprobe uinput || true
          sudo chmod 666 /dev/uinput || true

      - name: Install dependencies (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          brew update
          brew install cmake

      - name: Install dependencies (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          choco install -y cmake

      - name: Start Xvfb (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          # Start Xvfb in the background so GUI-related injection can run.
          Xvfb :99 -screen 0 1024x768x24 & sleep 2

      - name: Clean stale build directory (Unix)
        if: runner.os != 'Windows'
        run: rm -rf build

      - name: Clean stale build directory (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $path = 'build'
          if (Test-Path -LiteralPath $path) {
            try {
              Remove-Item -LiteralPath $path -Recurse -Force -ErrorAction Stop -Verbose
            } catch {
              Write-Host "Warning: failed to remove '$path': $($_.Exception.Message)"
              # Intentionally don't rethrow so the workflow step succeeds even if removal fails
            }
          } else {
            Write-Host "No build directory to remove"
          }

      - name: Configure (CMake, Linux/macOS)
        if: runner.os != 'Windows'
        run: cmake -S . -B build -DTYPR_IO_BUILD_TESTS=ON -DTYPR_IO_BUILD_INTEGRATION_TESTS=ON -DCMAKE_BUILD_TYPE=Release

      - name: Configure (CMake, Windows)
        if: runner.os == 'Windows'
        run: cmake -S . -B build -G "Visual Studio 17 2022" -A x64 -DTYPR_IO_BUILD_TESTS=ON -DTYPR_IO_BUILD_INTEGRATION_TESTS=ON

      - name: Build (CMake)
        run: cmake --build build --config Release --parallel

      - name: Find integration test binary (Unix)
        id: find-integration-binary-unix
        if: runner.os != 'Windows'
        run: |
          # Find the built integration test executable and emit its path as step output.
          found=$(find build -type f -name 'typr-io-integration-tests*' -print -quit || true)
          if [ -n "$found" ]; then
            echo "path=$found" >> $GITHUB_OUTPUT
          else
            echo "path=" >> $GITHUB_OUTPUT
          fi

      - name: Find integration test binary (Windows)
        id: find-integration-binary-windows
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Find the built integration test executable and emit its path as step output.
          $found = Get-ChildItem -Path build -Recurse -Filter 'typr-io-integration-tests*' -File -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($found) {
            Write-Output "path=$($found.FullName)" >> $env:GITHUB_OUTPUT
          } else {
            Write-Output "path=" >> $env:GITHUB_OUTPUT
          }

      - name: Upload integration test binary
        if: steps.find-integration-binary-unix.outputs.path != '' || steps.find-integration-binary-windows.outputs.path != ''
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-binary-${{ matrix.os }}
          path: ${{ steps.find-integration-binary-unix.outputs.path || steps.find-integration-binary-windows.outputs.path }}

      - name: Run integration tests (non-interactive by default)
        env:
          TYPR_IO_RUN_INTEGRATION_TESTS: ${{ env.TYPR_IO_RUN_INTEGRATION_TESTS }}
          TYPR_IO_AUTO_CONFIRM: ${{ env.TYPR_IO_AUTO_CONFIRM }}
          TYPR_IO_INTERACTIVE: ${{ env.TYPR_IO_INTERACTIVE }}
          DISPLAY: ${{ env.DISPLAY }}
          CTEST_OUTPUT_ON_FAILURE: "1"
        run: |
          # Run the integration test executable (built with TYPR_IO_BUILD_INTEGRATION_TESTS=ON).
          ctest --test-dir build --output-on-failure -R typr-io-integration-tests -C Release

      - name: Upload test logs (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-logs-${{ matrix.os }}
          path: |
            build/Testing
            build/tests || true

  release:
    name: Create integration test release
    runs-on: ubuntu-latest
    needs: integration
    if: ${{ always() }}
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all workflow artifacts
        uses: actions/download-artifact@v3
        with:
          path: artifacts
        continue-on-error: true

      - name: Prepare release assets
        run: |
          set -e
          mkdir -p release-assets
          shopt -s globstar || true
          for d in artifacts/*; do
            if [ -d "$d" ]; then
              for f in "$d"/**/typr-io-integration-tests*; do
                if [ -f "$f" ]; then
                  os=$(basename "$d" | sed 's/^integration-test-binary-//')
                  name="typr-io-integration-tests-${os}"
                  ext="${f##*.}"
                  if [ "$ext" = "$f" ]; then
                    # No extension
                    cp "$f" "release-assets/${name}"
                  else
                    cp "$f" "release-assets/${name}.${ext}"
                  fi
                fi
              done
            fi
          done
          echo "Prepared release assets:"
          ls -la release-assets || true

      - name: Check for release assets
        id: check-assets
        run: |
          if [ -n "$(ls -A release-assets 2>/dev/null || true)" ]; then
            echo "has_assets=true" >> $GITHUB_OUTPUT
          else
            echo "has_assets=false" >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub release and upload assets
        if: steps.check-assets.outputs.has_assets == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          DATE=$(date -u +%F)
          RELEASE_NAME="${DATE} integration tests"
          TAG="integration-tests-${DATE}"
          BODY="Integration test binaries produced by workflow run ${GITHUB_RUN_ID}."
          echo "Creating release ${RELEASE_NAME} (tag ${TAG})"
          resp=$(curl -s -X POST -H "Authorization: token $GITHUB_TOKEN" -H "Content-Type: application/json" \
            -d "{\"tag_name\":\"$TAG\",\"name\":\"$RELEASE_NAME\",\"body\":\"$BODY\",\"draft\":false,\"prerelease\":false}" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases")
          release_id=$(echo "$resp" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('id') or '')")
          upload_url=$(echo "$resp" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('upload_url') or '')")
          if [ -z "$release_id" ]; then
            echo "Release creation failed or already exists; fetching existing release by tag..."
            resp=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/$TAG")
            release_id=$(echo "$resp" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('id') or '')")
            upload_url=$(echo "$resp" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('upload_url') or '')")
          fi
          if [ -z "$upload_url" ]; then
            echo "Failed to determine upload URL for release"
            echo "$resp"
            exit 1
          fi
          # Trim the template suffix from upload_url if present (e.g. "{?name,label}")
          upload_url="${upload_url%\{*}"
          # Upload assets (delete any existing duplicate assets first)
          assets=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/$release_id/assets")
          for file in release-assets/*; do
            if [ -f "$file" ]; then
              name=$(basename "$file")
              # Delete existing asset with same name, if present
              asset_id=$(echo "$assets" | python3 -c "import sys, json; a=json.load(sys.stdin); import sys; name=sys.argv[1]; print(next((x.get('id') for x in a if x.get('name')==name), ''))" "$name")
              if [ -n "$asset_id" ] && [ "$asset_id" != "None" ]; then
                echo "Deleting existing asset $name (id $asset_id)"
                curl -s -X DELETE -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/assets/$asset_id"
              fi
              echo "Uploading $name"
              curl --fail -s -X POST -H "Authorization: token $GITHUB_TOKEN" -H "Content-Type: application/octet-stream" --data-binary @"$file" "${upload_url}?name=${name}"
            fi
          done
          echo "Release ${RELEASE_NAME} ready."
