name: Release

# Create a release when a tag starting with "v" is pushed (e.g. `v1.2.3`)
on:
  workflow_dispatch:
    inputs:
      version:
        description: "Version number"
        required: true
  push:
    tags:
      - "v*"

permissions:
  contents: write

concurrency:
  group: release-${{ github.ref_name }}
  cancel-in-progress: false

jobs:
  build-linux-x64:
    name: Build (ubuntu-latest / x86_64)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install dependencies (Linux)
        run: |
          sudo apt-get update
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y build-essential cmake pkg-config libinput-dev libxkbcommon-dev libudev-dev libx11-dev libxi-dev libxtst-dev libxrandr-dev libxcursor-dev libxinerama-dev

      - name: Clean stale directories
        run: rm -rf build dist packages || true

      - name: Configure (CMake)
        run: cmake -S . -B build -DTYPR_IO_BUILD_SHARED=ON -DTYPR_IO_BUILD_TESTS=OFF -DCMAKE_BUILD_TYPE=Release

      - name: Build (CMake)
        run: cmake --build build --config Release --parallel

      - name: Install to staging dir
        run: cmake --install build --prefix dist --config Release

      - name: Package library (tar.gz)
        run: |
          set -e
          TAG="${GITHUB_REF#refs/tags/}"
          mkdir -p packages
          tar -C dist -czf "packages/typr-io-${TAG}-linux-x86_64.tar.gz" .
          ls -la packages

      - name: Upload release package
        uses: actions/upload-artifact@v4
        with:
          name: release-package-linux-x86_64
          path: packages/*.tar.gz

  build-linux-arm64:
    name: Build (ubuntu-24.04-arm / arm64)
    runs-on: ubuntu-24.04-arm
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install dependencies (Linux)
        run: |
          sudo apt-get update
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y build-essential cmake pkg-config libinput-dev libxkbcommon-dev libudev-dev libx11-dev libxi-dev libxtst-dev libxrandr-dev libxcursor-dev libxinerama-dev

      - name: Clean stale directories
        run: rm -rf build dist packages || true

      - name: Configure (CMake)
        run: cmake -S . -B build -DTYPR_IO_BUILD_SHARED=ON -DTYPR_IO_BUILD_TESTS=OFF -DCMAKE_BUILD_TYPE=Release

      - name: Build (CMake)
        run: cmake --build build --config Release --parallel

      - name: Install to staging dir
        run: cmake --install build --prefix dist --config Release

      - name: Package library (tar.gz)
        run: |
          set -e
          TAG="${GITHUB_REF#refs/tags/}"
          mkdir -p packages
          tar -C dist -czf "packages/typr-io-${TAG}-linux-arm64.tar.gz" .
          ls -la packages

      - name: Upload release package
        uses: actions/upload-artifact@v4
        with:
          name: release-package-linux-arm64
          path: packages/*.tar.gz

  build-macos-x64:
    name: Build (macos-latest / x86_64)
    runs-on: macos-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install dependencies (macOS)
        run: |
          brew update
          brew install cmake

      - name: Clean stale directories
        run: rm -rf build dist packages || true

      - name: Configure (CMake, macOS/x86_64)
        run: cmake -S . -B build -DTYPR_IO_BUILD_SHARED=ON -DTYPR_IO_BUILD_TESTS=OFF -DCMAKE_BUILD_TYPE=Release -DCMAKE_OSX_ARCHITECTURES=x86_64

      - name: Build (CMake)
        run: cmake --build build --config Release --parallel

      - name: Install to staging dir
        run: cmake --install build --prefix dist --config Release

      - name: Package library (tar.gz)
        run: |
          set -e
          TAG="${GITHUB_REF#refs/tags/}"
          mkdir -p packages
          tar -C dist -czf "packages/typr-io-${TAG}-macos-x86_64.tar.gz" .
          ls -la packages

      - name: Upload release package
        uses: actions/upload-artifact@v4
        with:
          name: release-package-macos-x86_64
          path: packages/*.tar.gz

  build-macos-arm64:
    name: Build (macos-latest / arm64)
    runs-on: macos-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install dependencies (macOS)
        run: |
          brew update
          brew install cmake

      - name: Clean stale directories
        run: rm -rf build dist packages || true

      - name: Configure (CMake, macOS/arm64)
        run: cmake -S . -B build -DTYPR_IO_BUILD_SHARED=ON -DTYPR_IO_BUILD_TESTS=OFF -DCMAKE_BUILD_TYPE=Release -DCMAKE_OSX_ARCHITECTURES=arm64

      - name: Build (CMake)
        run: cmake --build build --config Release --parallel

      - name: Install to staging dir
        run: cmake --install build --prefix dist --config Release

      - name: Package library (tar.gz)
        run: |
          set -e
          TAG="${GITHUB_REF#refs/tags/}"
          mkdir -p packages
          tar -C dist -czf "packages/typr-io-${TAG}-macos-arm64.tar.gz" .
          ls -la packages

      - name: Upload release package
        uses: actions/upload-artifact@v4
        with:
          name: release-package-macos-arm64
          path: packages/*.tar.gz

  build-windows-x64:
    name: Build (windows-latest / x64)
    runs-on: windows-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install dependencies (Windows)
        shell: pwsh
        run: |
          if (-not (Get-Command cmake -ErrorAction SilentlyContinue)) {
            Write-Host "CMake not found, installing via Chocolatey..."
            $tries = 0
            $installed = $false
            do {
              $tries++
              Write-Host "Attempt $tries to ensure cmake via Chocolatey..."
              choco install -y cmake --install-arguments "'/l*v C:\cmake.install_msi_install.log'" --no-progress
              if ($LASTEXITCODE -ne 0) {
                Write-Host "choco install returned $LASTEXITCODE; trying 'choco upgrade -y cmake' as a fallback..."
                choco upgrade -y cmake --install-arguments "'/l*v C:\cmake.install_msi_install.log'" --no-progress
              }
              if ($LASTEXITCODE -eq 0 -or (Get-Command cmake -ErrorAction SilentlyContinue)) {
                $installed = $true
                break
              }
              Start-Sleep -Seconds (5 * $tries)
            } while ($tries -lt 3)
            if (-not $installed) {
              Write-Host "CMake installation failed after $tries attempts. See C:\cmake.install_msi_install.log for MSI details."
              exit 1
            }
          } else {
            Write-Host "CMake already installed: $(cmake --version)"
          }

      - name: Clean stale directories (Windows)
        shell: pwsh
        run: |
          if (Test-Path -LiteralPath 'build') {
            try {
              Remove-Item -LiteralPath 'build' -Recurse -Force -ErrorAction Stop -Verbose
            } catch {
              Write-Host "Warning: failed to remove 'build': $($_.Exception.Message)"
            }
          }
          Remove-Item -LiteralPath 'dist' -Recurse -Force -ErrorAction SilentlyContinue || $null
          Remove-Item -LiteralPath 'packages' -Recurse -Force -ErrorAction SilentlyContinue || $null

      - name: Configure (CMake, Windows)
        run: cmake -S . -B build -G "Visual Studio 17 2022" -A x64 -DTYPR_IO_BUILD_SHARED=ON -DTYPR_IO_BUILD_TESTS=OFF

      - name: Build (CMake)
        run: cmake --build build --config Release --parallel

      - name: Install to staging dir (Windows)
        run: cmake --install build --prefix "%cd%\\dist" --config Release

      - name: Package library (zip)
        shell: pwsh
        run: |
          $tag = $env:GITHUB_REF -replace '^refs/tags/',''
          New-Item -ItemType Directory -Path packages -Force | Out-Null
          $dest = "packages/typr-io-$($tag)-windows-x64.zip"
          if (Test-Path $dest) { Remove-Item $dest -Force }
          Compress-Archive -Path "dist\\*" -DestinationPath $dest -Force
          Get-ChildItem packages

      - name: Upload release package
        uses: actions/upload-artifact@v4
        with:
          name: release-package-windows-x64
          path: packages/*.zip

  build-windows-arm64:
    name: Build (windows-11-arm / arm64)
    runs-on: windows-11-arm
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install dependencies (Windows)
        shell: pwsh
        run: |
          if (-not (Get-Command cmake -ErrorAction SilentlyContinue)) {
            Write-Host "CMake not found, installing via Chocolatey..."
            $tries = 0
            $installed = $false
            do {
              $tries++
              Write-Host "Attempt $tries to ensure cmake via Chocolatey..."
              choco install -y cmake --install-arguments "'/l*v C:\cmake.install_msi_install.log'" --no-progress
              if ($LASTEXITCODE -ne 0) {
                Write-Host "choco install returned $LASTEXITCODE; trying 'choco upgrade -y cmake' as a fallback..."
                choco upgrade -y cmake --install-arguments "'/l*v C:\cmake.install_msi_install.log'" --no-progress
              }
              if ($LASTEXITCODE -eq 0 -or (Get-Command cmake -ErrorAction SilentlyContinue)) {
                $installed = $true
                break
              }
              Start-Sleep -Seconds (5 * $tries)
            } while ($tries -lt 3)
            if (-not $installed) {
              Write-Host "CMake installation failed after $tries attempts. See C:\cmake.install_msi_install.log for MSI details."
              exit 1
            }
          } else {
            Write-Host "CMake already installed: $(cmake --version)"
          }

      - name: Clean stale directories (Windows)
        shell: pwsh
        run: |
          if (Test-Path -LiteralPath 'build') {
            try {
              Remove-Item -LiteralPath 'build' -Recurse -Force -ErrorAction Stop -Verbose
            } catch {
              Write-Host "Warning: failed to remove 'build': $($_.Exception.Message)"
            }
          }
          Remove-Item -LiteralPath 'dist' -Recurse -Force -ErrorAction SilentlyContinue || $null
          Remove-Item -LiteralPath 'packages' -Recurse -Force -ErrorAction SilentlyContinue || $null

      - name: Configure (CMake, Windows ARM64)
        run: cmake -S . -B build -G "Visual Studio 17 2022" -A ARM64 -DTYPR_IO_BUILD_SHARED=ON -DTYPR_IO_BUILD_TESTS=OFF

      - name: Build (CMake)
        run: cmake --build build --config Release --parallel

      - name: Install to staging dir (Windows ARM64)
        run: cmake --install build --prefix "%cd%\\dist" --config Release

      - name: Package library (zip)
        shell: pwsh
        run: |
          $tag = $env:GITHUB_REF -replace '^refs/tags/',''
          New-Item -ItemType Directory -Path packages -Force | Out-Null
          $dest = "packages/typr-io-$($tag)-windows-arm64.zip"
          if (Test-Path $dest) { Remove-Item $dest -Force }
          Compress-Archive -Path "dist\\*" -DestinationPath $dest -Force
          Get-ChildItem packages

      - name: Upload release package
        uses: actions/upload-artifact@v4
        with:
          name: release-package-windows-arm64
          path: packages/*.zip

  create-release:
    name: Create GitHub release and upload assets
    runs-on: ubuntu-latest
    needs:
      - build-linux-x64
      - build-linux-arm64
      - build-macos-x64
      - build-macos-arm64
      - build-windows-x64
      - build-windows-arm64
    if: ${{ always() }}
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download all workflow artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
        continue-on-error: true

      - name: Prepare release assets
        run: |
          set -e
          mkdir -p release-assets
          shopt -s globstar || true
          for d in artifacts/*; do
            if [ -d "$d" ]; then
              for f in "$d"/*; do
                if [ -f "$f" ]; then
                  cp "$f" "release-assets/$(basename "$f")"
                fi
              done
            fi
          done
          echo "Prepared release assets:"
          ls -la release-assets || true

      - name: Check for release assets
        id: check-assets
        run: |
          if [ -n "$(ls -A release-assets 2>/dev/null || true)" ]; then
            echo "has_assets=true" >> $GITHUB_OUTPUT
          else
            echo "has_assets=false" >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub release and upload assets
        if: steps.check-assets.outputs.has_assets == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF#refs/tags/}"
          # Try to use annotated tag message as body if available, otherwise fallback to commit message
          BODY="$(git for-each-ref --format='%(contents)' "refs/tags/$TAG" 2>/dev/null || true)"
          if [ -z "$BODY" ]; then
            BODY="$(git log -1 --pretty=%B 2>/dev/null || echo "Release $TAG")"
          fi
          RELEASE_NAME="$TAG"
          echo "Creating release ${RELEASE_NAME} (tag ${TAG})"
          resp=$(curl -s -X POST -H "Authorization: token $GITHUB_TOKEN" -H "Content-Type: application/json" \
            -d "{\"tag_name\":\"$TAG\",\"name\":\"$RELEASE_NAME\",\"body\":\"$BODY\",\"draft\":false,\"prerelease\":false}" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases")
          release_id=$(echo "$resp" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('id') or '')")
          upload_url=$(echo "$resp" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('upload_url') or '')")
          if [ -z "$release_id" ]; then
            echo "Release creation failed or already exists; fetching existing release by tag..."
            resp=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/$TAG")
            release_id=$(echo "$resp" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('id') or '')")
            upload_url=$(echo "$resp" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('upload_url') or '')")
          fi
          if [ -z "$upload_url" ]; then
            echo "Failed to determine upload URL for release"
            echo "$resp"
            exit 1
          fi
          # Trim the template suffix from upload_url if present (e.g. "{?name,label}")
          upload_url="${upload_url%\{*}"
          # Upload assets (delete any existing duplicate assets first)
          assets=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/$release_id/assets")
          for file in release-assets/*; do
            if [ -f "$file" ]; then
              name=$(basename "$file")
              # Delete existing asset with same name, if present
              asset_id=$(echo "$assets" | python3 -c "import sys, json; a=json.load(sys.stdin); import sys; name=sys.argv[1]; print(next((x.get('id') for x in a if x.get('name')==name), ''))" "$name")
              if [ -n "$asset_id" ] && [ "$asset_id" != "None" ]; then
                echo "Deleting existing asset $name (id $asset_id)"
                curl -s -X DELETE -H "Authorization: token $GITHUB_TOKEN" "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/assets/$asset_id"
              fi
              echo "Uploading $name"
              curl --fail -s -X POST -H "Authorization: token $GITHUB_TOKEN" -H "Content-Type: application/octet-stream" --data-binary @"$file" "${upload_url}?name=${name}"
            fi
          done
          echo "Release ${RELEASE_NAME} ready."
